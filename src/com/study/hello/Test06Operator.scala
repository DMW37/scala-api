package com.study.hello

/**
 * @author: 邓明维
 * @date: 2022/11/22
 * @description:
 */
object Test06Operator {
  def main(args: Array[String]): Unit = {
    /**
     * TODO: 算术运算符
     * + 正号、加法、字符串拼接符
     * - 负号、减法
     * 乘法
     * / 除法，除数不能为 0
     * % 取余
     * 注意：
     * Scala 没有 ++ 和 -- 算术运算符；
     * 整数相除的结果，还是整数，如果想获得小数，必须有浮点型数据参与运算；例如：10 / 3 = 3，10 / 3.0 = 3.33333...；
     * 关于 % 取余操作，假设 a % b ，底层实现原理为： a - a / b * b 。
     *
     */

    val a = +2;
    val b = 3;
    println(a % b)

    /**
     * TODO:赋值运算符
     * 基本赋值运算符 = 例如：var a = 2，把 2 赋值给变量 a
     * 扩展赋值运算符 += 、 -= 、 *= 、 /= 、 %= 例如：a += 3，把变量 a 加 3 后再重新赋值回 a
     */
    var c = 10
    var d = 3
    c += d
    println(c)

    /**
     * TODO:关系运算符
     * > 判断左边是否大于右边
     * >= 判断左边是否大于或者等于右边
     * < 判断左边是否小于右边
     * <= 判断左边是否小于或者等于右边
     * == 判断左边是否等于右边
     * != 判断左边是否不等于右边
     */

    val s1 = "abc"
    val s2 = s1 + ""
    println(s1 == s1) // 结果为 true，因为比较的是数据值
    println(s1.eq(s2)) // 结果为 false，因为比较的是地址值

    /**
     * TODO:. 逻辑运算符
     * & 逻辑与，要求所有条件都满足。简单理解：左右两边，有 false 则整体为 false
     * | 逻辑或，要求只要满足任意一个条件即可。简单理解：左右两边，有 true 则整体为 true
     * && 逻辑短路与，要求所有条件都满足。简单理解：如果左边为 false 则右边不执行
     * || 逻辑短路或，要求只要满足任意一个条件即可。简单理解：如果左边为 true 则右边不执行
     * ! 逻辑非，对表达式的结果进行取反操作。简单理解：表达式结果为 true 取反则为 false
     */

    /**
     * TODO：位运算符
     * 二进制 数据以 0b(大小写均可)开头，由数字 0 和 1 组成 0b01100100，0b00011110
     * 八进制 数据以 组0 开头，由数字 0 ~ 7 成 0144，036
     * 十进制 现实生活中使用最多的进制，无特殊规则，由数字 0 ~ 9 组成 100，30
     * 十六进制 数据以 0x(大小写均可)开头，由数字 0 ~ 9，字母 A-F 组成(大小写均可) 0x64，0x1E
     */
    /**
     * TODO:整数的原码/反码/补码
     * 正数：三码合一（即正数的原码、反码、补码都一样）
     * 负数：
     * 原码：保留符号位，其余位不变
     * 反码：原码符号位不变，其余位按位取反
     * 补码：反码 + 1
     * 注意：计算机底层存储、运算都是采用二进制的补码形式来实现。
     *
     * & 按位与，规则：有 0 为 0，都为 1 则为 1
     * | 按位或，规则：有 1 为 1，都为 0 则为 0
     * ^ 按位异或，规则：相同为 0，不同为 1
     * ~ 按位取反，规则：0 变 1，1 变 0
     * << 按位左移，规则：每左移一位，相当于该数据乘以 2，例如：2 << 1，结果为 4
     * >> 按位右移，规则：每右移一位，相当于该数据除以 2，例如：6 >> 1，结果为 3
     */
    // 0000 0011
    var e = 3;
    // 0000 0110
    var f = 6;
    // 0000 0010  = 2
    println(e&f)

    // 0000 0111  = 7
    println(e|f)

    // 0000 0101   = 5
    println(e^f)

    // 0000 0011 补码
    // 1111 1100 补码
    // 1000 0011 反码
    // 1000 0110 原码
    println(~e)

    // 0000 0011
    // 0000 1100 = 8+4
    println(e<<2)

    println(-1>>>2)
  }
}
